\documentclass[12pt,english,a4paper]{report}

\usepackage[utf8]{inputenc}          % Allows UTF-8 encoded characters in the .tex-file.
\usepackage{babel,csquotes,textcomp,duomasterforside} % Set LaTeX to structure the content following international academic standards.

\usepackage[toc,page]{appendix}

\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{listings}
\usepackage{wrapfig}
\usepackage{color,colortbl}
\usepackage{lettrine}
\usepackage[font={small,it}]{caption}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{footnote}

\usepackage{subfiles}

% Making the whole paragraph biz possible
%\usepackage{titlesec}
%\setcounter{secnumdepth}{4}
%\titleformat{\paragraph}
%{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
%\titlespacing*{\paragraph}
%{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

% Adding the bib
\usepackage[
    backend=biber,
    style=numeric
]{biblatex}
\addbibresource{refs.bib}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{auxiliryc}{RGB}{70,240,161} %Green
\definecolor{ineffectivec}{RGB}{70,149,240} %purple
\definecolor{effectivec}{RGB}{115,70,240} % Blue

\graphicspath{{./graphics/}}

% Setting tty font?
\lstset{ %
  basicstyle=\ttfamily\tiny,     
  backgroundcolor=\color{white},   % choose the background color
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
  showspaces=false,
  showstringspaces=false,
}

\title{GPS Spoofing}
\subtitle{A detection and mitigation system}
\author{Aril Schultzen}
\begin{document}
\duoforside[dept={Institutt for informatikk},
program={Informatikk: programmering og nettverk},
long]

\begin{abstract}
Abstract goes here.
\end{abstract}

\chapter*{Foreword}
Here goes foreword

% Hackish code to keep counters and white pages at bay
\thispagestyle{empty}
\setcounter{page}{0}
%\newpage
\tableofcontents
\thispagestyle{empty}
\setcounter{page}{0}
%\newpage
\thispagestyle{empty}
\setcounter{page}{0}
%\newpage
\clearpage
\setcounter{page}{1}

% Here goes all the chapters
% ==================================================

\subfile{intro}

% Chapter about the csac and it's connectivity?

\newpage
\chapter{Method}
\section{Data acquisition}
In order to create an accurate clock-model of the CSAC, it was necessary to log data from it while it was running in a disciplined mode. In the disciplined mode, the CSAC will correct it's frequency based on either a 1 PPS (Pulse per second) signal or 10 MHz signal. The Ublox-M8T GPS receiver was specifically designed for timing purposes and was used in this instance to provide the 1 PPS signal for disciplining purposes. A similar approach was used in order to collect GPS data. Data from two Ublox-M8T was gathered over the same time period as the data gathered from the CSAC. By gathering the data over the same period, it was possible to detect any correlation between the time solved by the GPS receivers and any frequency adjustments done by the CSAC. It also provided valuable data that could be used to tune the spoofing detection algorithms in the CSAC SMACC. The data gathering was done by simple Python scripts (\ref{CL} and \ref{GL}) running on a computer connected to the receivers and the CSAC (\ref{CLS})

\newpage

\section{Programming of SMACC software}

\subsection{Intro}
The software that makes the SMACC smart, consists of multiple modules. There is a server that manages connection and acts as an interface to the system as a whole. There is a client that connects to the server and relays relevant GPS data and finally, the software running on the micro-controller embedded in the CSAC. The latter is of course not made by us, but paramount in order for our proposal to work. In this chapter, these different parts or modules will be explained.

\subsection{Choice of language}
The SMACC software was written in C99. This might seem like a strange choice when given alternatives like C++, Java or Python, but C99 offered the following for me:
\begin{itemize}
  \item Better portability than C11
  \item More modern than C89
  \item Efficient and fast
  \item Exciting
  \item I have limited experience with it
\end{itemize}
The three first points probably makes perfect sense, but to me it was just as important that i learned a new and exciting language. 

\subsubsection{The client software}
The client software takes the servers IP and port as parameter. It then loads its configuration file and reads the path to the connected GPS receiver and an ID number. The GPS receiver is used to fetch GPS data and the ID number is used to identify itself for the server. It then parses the NMEA data it receives and relays the relevant data to the server. 

\subsubsection{The server}
The server follows a standard web server-like pattern:
\begin{itemize}
  \item Wait for connections
  \item Fork out a new process for the new connection
  \item Repeat
\end{itemize}
However, the similarities end there. The servers job can be divided into three parts:
\begin{itemize}
  \item Manage connections
  \item Handle information received from clients (state)
  \item Process information received from clients
\end{itemize}
\subsubsection{Data structures and shared memory}
Since the server needs to have access to all the data the clients transmit, it uses a shared memory model. Every process that forks out from the server is given access to this memory area. Even the processes themselves have access to each others memory. One might make the point that this voids the idea of processes, and one might be correct. The shared memory is created using MMAP.
\begin{lstlisting}
client_list = mmap(NULL, 
                  (s_conf->max_clients * sizeof(struct client_table_entry)), 
                  PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
\end{lstlisting}
The example over shows how shared memory is allocated. The observant reader will notice that there is allocated memory for a finite number of clients. This is unfortunate but necessary and not really much a problem. The reason however, is that a process as a child inherits all the variables and state from it's parent. This also means that the shared memory has to have the same layout throughout the programs execution for all the processes to have the same "version" of the shared memory. As long as a process only uses the shared memory allocated for itself, it is not a problem, but once it attempts to access the memory of a younger sibling process, it cannot access that area and the process will crash. In this application however, we always know how many clients are going to connect. Even when in doubt, the maximum number of clients can be grossly overestimated and configured in order to make sure that there is room.

\subsubsection{Managing connections}

\subsubsection{The CSAC}

\subsection{Different approaches}
What is the point of using processes when they aren't even separated? All the bad with none of the good one might argue. 

Why even do this in C? Would be faster to do it in Python and rather just have all the Raspberry's store their data in a database and analyze it regularly. 

\newpage
\chapter{Testing}

\newpage
\chapter{Results and discussion}


\newpage
\chapter{Conclusion}

\newpage
\subfile{appendix}

%===================================================

\newpage
\printbibliography[title={Complete Bibliography},heading=bibintoc]

\end{document}                    