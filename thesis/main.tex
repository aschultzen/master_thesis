\documentclass[12pt,english,a4paper]{report}

\usepackage[utf8]{inputenc}          % Allows UTF-8 encoded characters in the .tex-file.
\usepackage{babel,csquotes,textcomp,duomasterforside} % Set LaTeX to structure the content following international academic standards.

\usepackage[toc,page]{appendix}

\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{listings}
\usepackage{wrapfig}
\usepackage{color,colortbl}
\usepackage{lettrine}
\usepackage[font={small,it}]{caption}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{footnote}

\usepackage{subfiles}

% Making the whole paragraph biz possible
%\usepackage{titlesec}
%\setcounter{secnumdepth}{4}
%\titleformat{\paragraph}
%{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
%\titlespacing*{\paragraph}
%{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

% Adding the bib
\usepackage[
    backend=biber,
    style=numeric
]{biblatex}
\addbibresource{refs.bib}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{auxiliryc}{RGB}{70,240,161} %Green
\definecolor{ineffectivec}{RGB}{70,149,240} %purple
\definecolor{effectivec}{RGB}{115,70,240} % Blue

\graphicspath{{./graphics/}}

% Setting tty font?
\lstset{ %
  basicstyle=\ttfamily\small,     
  backgroundcolor=\color{white},   % choose the background color
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
  showspaces=false,
  showstringspaces=false,
}

\title{GPS Spoofing}
\subtitle{A detection and mitigation system}
\author{Aril Schultzen}
\begin{document}
\duoforside[dept={Institutt for informatikk},
program={Informatikk: programmering og nettverk},
long]

\begin{abstract}
Abstract goes here.
\end{abstract}

\chapter*{Foreword}
Here goes foreword

% Hackish code to keep counters and white pages at bay
\thispagestyle{empty}
\setcounter{page}{0}
\tableofcontents
\thispagestyle{empty}
\setcounter{page}{0}
\thispagestyle{empty}
\setcounter{page}{0}
\clearpage
\setcounter{page}{1}

% Here goes all the chapters
% ==================================================

\subfile{intro}

% Chapter about the csac and it's connectivity?

\chapter{Method}
\section{SMACC software programming}

\subsection{Intro}
% Make sure that this is true!
\subsection{Choice of language}
The SMACC software was originally planned to be written in Java since this was my most fluent programming language. Java is great language, it's object oriented, it has a garbage collector and a lot of useful libraries. As development started, it quickly became apparent that some parts of the code would be performance critical and that portability really wasn't that important anyway. The platform was already decided and there was no reason to believe that it would change in the near future. As we all know, premature optimization is the root of all evil. Being reluctant to commit a deadly programming sin, i decided to look at other languages. Since performance was a concern, Python was also quickly dismissed as an option. C++ would probably have been the best choice, but having never written anything in C before, made it sound more exciting and a nice opportunity to learn something new. During the planning phase of SMACC development, raspbian-2015-05-07 was the latest build. It came with GCC 4.6 which only had experimental support for C11(\cite{GCC11}), this meant that C99 was the safest choice. 

% Insert graph showing spread in GPS data
\subsection{Client-server model}
Originally, the SMACC software was planned to be a simple program running a RASPI with GPS receivers connected to it through the USB ports. After having collected a considerable amount of data (\ref{data_aquisition}) it became obvious that the two GPS receivers probably should be placed at a distance of at least X meter from each other. This also meant that long coaxial cables had to be made. I proposed to instead change the plans for the SMACC software to use a Client-server model where each GNSS receiver had a RASPI attached and could be viewed as a single unit, or "sensor". The RASPI's connected to the GNSS receivers would not do any heavy lifting, but instead work as network card with a completely overkill Linux system attached. This way, a sensor could communicate with the SMACC software, now a "server", over TCP/IP and thus be placed much farther away. This also removed the restrictions on possible number of GNSS receivers as one would eventually run out of USB ports.  

\subsubsection{The client}
The sensor\_client software is a simple program that reads from the GNSS receivers and "looks" for lines starting with either \texttt{\$GNRMC} or \texttt{\$GNGGA}. %Continue here

\subsection{Components}


\subsection{Data structures and shared memory}
Since the server needs to have access to all the data the clients transmit, it uses a shared memory model. Every process that forks out from the server is given access to this memory area. Even the processes themselves have access to each others memory. One might make the point that this voids the idea of processes, and one might be correct (see \ref{discussion}). The shared memory is created using the GNU library's Memory Mapped I/O (MMAP). Although typically used to map files to a region of memory, MMAP can also be used to create an anonymous map which are not connected to file but rather for sharing data between tasks without using files.

\begin{lstlisting}
client_list = mmap(NULL, 
                  (s_conf->max_clients * sizeof(struct client_table_entry)), 
                  PROT_READ | PROT_WRITE,
                  MAP_SHARED | MAP_ANONYMOUS,
                  -1, 0);
\end{lstlisting}

The example over shows how shared memory is allocated. The observant reader will notice that there memory is allocated for a finite number of clients. This is unfortunate but necessary: The fork operation creates a completely separate address space for the child process but the child still has a complete copy of parents memory segments. Since the child process is completely separated from the parent, any changes in the shared memory done by the parent will not be "reflected" in the child's memory. In other words, the entire shared memory \textit{has} to be initialized before any fork operations are done. Failing to do so will result in a segmentation fault once a process attempts to access the memory of a younger sibling. In this application however, we always know how many clients are going to connect. Even when in doubt, the maximum number of clients can be grossly overestimated and configured in order to make sure that there is room for more clients.

\subsection{Managing connections}

\subsection{The CSAC}
Write about the CSAC and the serial communication. Perhaps mention the how the communication between the server and the CSAC works?

\subsection{Detection algorithms: Filters}
\section{Data acquisition}\label{data_aquisition}
In order to create an accurate clock-model of the CSAC, it was necessary to log data from it while it was running in a disciplined mode. In the disciplined mode, the CSAC will correct it's frequency based on either a 1 PPS (Pulse per second) signal or a 10 MHz signal. A similar approach was used in order to collect GPS data. Data from two u-blox M8T was gathered over the same time period as the data gathered from the CSAC. By gathering the data over the same period, it was possible to detect any correlation between the time solved by the GPS receivers and any frequency adjustments done by the CSAC. It also provided valuable data that could be used to tune the spoofing detection algorithms in the CSAC SMACC. The data gathering was done by simple Python scripts (\ref{CL} and \ref{GL}) running on a computer connected to the receivers and the CSAC (\ref{CLS})

\subsubsection{Clock Model}
Write about Harald's clock model

\subsubsection{Naive MIN-MAX filter}
The MIN-MAX filter is one of the least sophisticated filters implemented. Data is gathered over a pre-determined "warm-up" period and the server compares the lowest and highest values of this data with current data. If the values are either higher or lower than the collected data, the data is considered abnormal. 

\subsubsection{Probability filter}
The "probability filter" is implemented by using collected data to create a model of expected data. The current data is then compared in order to evaluate whether or not it is abnormal. 

\chapter{Testing}

\section{Software performance}
How was the performance of the server? Slow? Buggy?

\section{Preliminary test}
Wave those antennas around

\section{Spoof test}
\subsection{Challenges}
What if their clocks sucks?

\subsection{The test}
Write about the test

\chapter{Results and discussion}\label{discussion}

\subsection{Different approaches}
What is the point of using processes when they aren't even separated? All the bad with none of the good one might argue. 

Why even do this in C? Would be faster to do it in Python and rather just have all the Raspberry's store their data in a database and analyze it regularly. 

\chapter{Conclusion}

\subfile{appendix}

%===================================================

\newpage
\printbibliography[title={Complete Bibliography},heading=bibintoc]

\end{document}                    